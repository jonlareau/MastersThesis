
	  SPeech HEader REsources (SPHERE) Version 2.0 Beta2
			   August 27, 1993

                   John Garofolo and Jonathan Fiscus
                                 NIST


Table of Contents:

I.      Introduction to SPHERE

II.     C-language Programmer Interface Library
	
	II.A   File Access Functions

		II.A.1	sp_open()
		II.A.1	sp_close()

	II.B   Header Manipulation Functions

		II.B.1	sp_h_get_field()
		II.B.2	sp_h_set_field()
		II.B.3	sp_h_delete_field()
	
	II.C   Waveform I/O and Conversion Functions

		II.C.1	sp_read_data()
		II.C.2	sp_write_data()
                II.C.3  sp_set_data_mode()

	II.D   Status Functions

                II.D.1  sp_eof()
                II.D.2  sp_error()
                II.D.3  sp_print_return_status()
                II.D.4  sp_get_return_status()

III.    File Format Definition

IV.     File Pointer Structure

VI.     Linking to the SPHERE library

VII.    Example Interface Library Usage

VIII.   System-Level Utilities

IX.     Revision History

X.      Bug Reports

XI.	Supported Hardware

XII.    Disclaimer

XIII.   Acknowlegements



I.  Introduction to SPHERE

SPeech HEader REsources (SPHERE) is a software package developed by
the National Institute of Standards and Technology (NIST) Automated
Speech Recognition Group to provide an interface to NIST
SPHERE-formatted speech waveform files.  (The acronym, SPHERE, has now
come to represent the format of the files as well as the software
package.)  

The SPHERE package contains two primary user-oriented software
components:

	1.  C-language programmer interface library

	2.  C-language system-level file manipulation utilities

The C-language programmer interface library has been developed to
provide a simple, intuitive interface to access and manipulate SPHERE
files.  The library has been specifically designed to mimic the syntax
and functionality of standard C-language file I/O functions.
Functions are provided to open, close, read, and write SPHERE files.
C-like header field manipulation functions have been included as well.

The system-level file manipulation utilities have been written using
the SPHERE library and provide command-line-level manipulation of
SPHERE files as well as functional examples of the usage of the SPHERE
libraries.

Where former versions of SPHERE provided only speech file header
access, Version 2.0 provides waveform access as well in both the
C-language programmer interface and system-level utilities.  Embedded
u-law, shorten, and wavpack compression/decompression is also
supported.



II.  C-language Programmer Interface Library.

    The SPHERE interface library functions provide a high-level
C-program interface to access and manipulate SPHERE-formatted files.
Many of the interface functions have been designed specifically 
to mimic standard C-language I/O functions.  Functions are 
included to provide SPHERE file access and separate manipulation
of file headers and bodies (waveforms). The functions have been
logically divided into four broad types:

	1.  File access functions (open and close SPHERE FILES)
	2.  Header manipulation functions
	3.  Waveform I/O and conversion functions
	4.  File I/O error status functions


1.  File access functions:

   SPHERE file access is achieved via the 'sp_open' function.  The

'sp_open' function is analogous to the C-language 'fopen' function and
controls the opening of files.  Upon opening for read operations, a
SPHERE file structure is formed and the header is loaded.  For
write operations, a SPHERE file structure is formed and an empty
header is created.

  The 'sp_close' function is analogous to the C-language 'fclose' function
and closes the specified SPHERE file and frees up associated allocated
memory.


2.  Header manipulation functions:

   Opened SPHERE header structures are manipulated via a set of header
field functions to retrieve, write, and delete fields.  The function,
'sp_h_get_field', is used to retrieve the contents of the three types
of SPHERE fields.  Likewise, the function, 'sp_h_set_field', is used
to establish the contents of the three types of SPHERE fields.  These
functions are somewhat analogous to the C-language 'gets' and 'puts'
functions.  The function, 'sp_h_delete_field', is used to remove a
field from a header.


3.  Waveform I/O and conversion functions

   A set of three functions has been established to handle waveform
I/O.  The first, 'sp_read_data', is used to load a block of waveform
data from a SPHERE file into memory.  This function is analogous to
the C-language 'fread' function.  Likewise, the function,
'sp_write_data', is used to flush a block of waveform data in memory
to SPHERE file and is analogous to the C-language 'fwrite' function.
The function, 'sp_set_data_mode', is used to change the default
behavior of 'sp_read_data' and 'sp_write_data' and controls such
variables as the conversion of waveform encodings and the byte order
during I/O.

Currently, only block-style sequential file access is supported.


4.  File I/O error status functions

   The functions, 'sp_eof' and 'sp_error', have been added to
provide file I/O status information analogous to the C-language
'feof' and 'ferror' functions.

The following sub-sections contain a detailed description template for
each function.  The templates are comprised of the following fields:

	Description - Brief general description of the purpose of the function
	Syntax - Function type and syntax including argument list
	Arguments - Description of arguments passed to the function
	Remarks - General comments and advisories regarding the function
	Return Value - Interpretation of the return values of the function
	See Also - List of related functions
	

II.A   File Access Functions


II.A.1 sp_open()

Description:

    Opens a SPHERE-formatted file and returns a SPHERE file pointer to
    the opened file.

Syntax:

    struct SP_FILE *sp_open(char *filename, char *mode)
	
Arguments:

    sp_open opens the file named by the string, 'filename', as
    instructed by the string, 'mode'.  

    The 'mode' string has the following values:

	"r[v]" -> Open a SPHERE file specified by the string, 'filename',
                  for reading.

	"w[v]" -> Open a SPHERE file specified by the string, 'filename',
                  for writing.

Remarks:

    Although a checksum is always generated upon completion of
    reading or writing any SPHERE file, an extra checksum verification
    may be performed using the optional 'v' modifier to
    'r' and 'w'.

    'rv' Checksum Verification:

    If a file is opened for read operations with the checksum
    verification flag, the checksum is verified before the
    file is made available for read operations.  Normally, the
    checksum is verified upon completion of reading a file.

    'wv' Checksum Verification:
   
    If a file is opened for write operations with the checksum
    verification flag, after a file is written, it is re-read and
    the checksum is verified.  Normally, if a checksum is present in the 
    file header before initiating write operations, then the existing
    checksum is verified against a checksum generated upon closing
    the file (with sp_close).  If a checksum is not present in the
    file header before initiating write operations, then a initial
    checksum is computed and no checksum verification takes placed.
    

Return Value:

    Returns a pointer to an opened SP_FILE structure.  If an error
    occurs during the open, returns a null pointer to a SP_FILE
    structure, "(SP_FILE *)0".

See Also:
    sp_read_data(), sp_write_data(), sp_set_data_mode(), sp_close()


II.A.2 sp_close()

Description:

    Closes an opened SPHERE-formatted file.

Syntax:

    int sp_close(SP_FILE *sp)
	
Arguments:

    sp_close closes the file pointed to by 'sp'.  

Remarks:

    Upon closing the file, '*sp' sp_close frees the memory allocated
for the file buffer.

Return Value:

    Returns 100 or greater on failure, otherwise returns a zero.

See Also:
    sp_read_data(), sp_write_data(), sp_set_data_mode(), sp_open()



II.B   Header Manipulation Functions

II.B.1 sp_h_get_field()

Description:

    Gets the specified header field value from an opened SPHERE file
header.

Syntax:

    int sp_h_get_field(SP_FILE *sp_file, char *field_name,
                       int field_type, void **field_value)

Arguments:

    sp_h_get_field copies the header field named by, 'field_name', of
type, 'field_type', from the opened SPHERE file pointed to by
'sp_file', to address pointed to by 'field_value'.

Remarks:

    Permitted field_type values:
       T_STRING    (string field type [char*])
       T_INTEGER   (integer field type [long*])
       T_REAL      (real field type [double*])


Note: in the case of a string field type (T_STRING), sp_h_get_field()
allocates sufficient dynamic memory for the string to be copied.  The
copied string is a NULL terminated sequence of characters.  It is the
programmer's responsibility to deallocate this memory using the
C-Language 'free()' function when the string is no longer needed.

Return Value:

    sp_h_get_field() returns a 0 upon success, 1 to 99 for a warning,
and 100 or greater for an error.

See Also:

    sp_open()


II.B.2 sp_h_set_field()

Description:

    Sets the specified header field value in an opened SPHERE file
header.

Syntax:

    int sp_h_set_field(SP_FILE *sp_file, char *field_name, 
                       char* field_type, void *field_value)
	
Arguments:

    sp_h_set_field sets the header field value named by, 'field_name',
of type, 'field_type', in the opened SPHERE file pointed to by
'sp_file' with the value, 'field_value'.

Remarks:

    Permitted field_type values:
       T_STRING    (string field type [char*])
       T_INTEGER   (integer field type [long*])
       T_REAL      (real field type [double*])

    If the specified header field, 'field_name', does not exist in the
opened SPHERE file header, then the field is created.

Note: If a file is opened for write (using 'sp_open'), then this
function may only be called before using 'sp_write_data'.  Also,
the fields, 'sample_coding', 'sample_byte_format', 'sample_count',
'sample_n_bytes', 'sample_checksum', are set automatically by
the function, 'sp_set_data_mode', and should not be set manually
if 'sp_set_data_mode' has been called.

Return Value:
    sp_h_get_field() returns a 0 upon success, 1 to 99 for a warning,
and 100 or greater for an error.

See Also:
    sp_open()


II.B.3 sp_h_delete_field()

Description:

    Deletes the specified header field from an opened SPHERE file
header.

Syntax:

    int sp_h_delete_field(SP_FILE *sp_file, char *field_name)
	
Arguments:

    sp_h_delete_field deletes the header field named by,
'field_name', in the opened SPHERE file pointed to by 'sp_file'.

Remarks:

    If the specified header field to be deleted, 'field_name', does
not exist in the opened SPHERE file header, sp_h_delete_field() will
not complain, but will return a special value (see below).  Return
Value:

Return Value:

    sp_h_delete_field() returns a 0 on sucess, a 1 if the header
field does not exist, and a 100 or greater on error.

See Also:
    sp_open(), sp_h_set_field(), sp_h_get_field()


II.C   Waveform I/O Functions

II.C.1 sp_read_data()

Description:
   
    Reads blocks of waveform data from an opened SPHERE file.

Syntax:

    int sp_read_data(void *ptr, size_t size, size_t n, SP_FILE *sp_file)

Arguments:

    Reads 'n' elements of size 'size' (in bytes) from the waveform
data section of the opened SPHERE file pointed to by 'sp_file'.
Performs the read (including any conversions as necessary) to format
the data according to the primary (base) encoding specified in the
header field, 'sample_coding'. 

Remarks:

    If there is no 'sample_coding' field in the header, the default
operation is to read the data as PCM data.  The default behavior of
'sp_read_data()' can be modified by the function 'sp_set_data_mode()'
before 'sp_read_data()' is called.  If a checksum is present in
the header, the checksum is verified after reading the last 
block of data.

Return Value:

    The value returned by 'sp_read_data' indicates the number of
elements read in from the file.  If no elements are read, a zero is
returned.  Likewise, if an error or checksum verification error
occurs, a zero is returned.  The functions 'sp_eof()' and 'sp_error()'
may be used to determine if an error or an immediate end-of-file
caused the zero to be returned.

See Also:

    sp_eof(), sp_error(), sp_set_data_mode()


II.C.2 sp_write_data()

Description:
   
    Writes blocks of waveform data to an opened SPHERE file.

Syntax:

    int sp_write_data(void *ptr, size_t size, size_t n, SP_FILE *sp_file)

Arguments:

    Appends 'n' elements of size 'size' (in bytes) to the end of the
waveform data section of the opened SPHERE file pointed to by
'sp_file'.

Remarks:

    sp_write_data() uses the 'sample_coding', 'channel_count'
'sample_byte_format' and 'sample_n_bytes' fields of the header in the
'sp_file' structure to identify the format of the data in memory to
be written.  The default behavior is for the data to be written as
it is represented in memory (as specified by the above header fields).

    The default behavior of 'sp_write_data()' can be modified by the
function 'sp_set_data_mode()' before 'sp_write_data()' is called.
'sp_set_data_mode()' allows the programmer to specify waveform data
transformations as the data is written.

Return Value:

    The value returned by 'sp_write_data' indicates the number of
elements written to the file pointed to by the 'sp_file' structure.
Incomplete writes are not flagged by the function.  It is the
programmer's responsibility to make sure that the return value equals
'n'.

See Also:

    sp_eof(), sp_error(), sp_set_data_mode()


II.C.3 sp_set_data_mode()

Description:
   
    Changes the default behavior of the SPHERE File I/O functions, 
'sp_read_data()' and 'sp_write_data()'.

Syntax:

    int sp_set_data_mode(SP_FILE *sp_file, char *mode)

Arguments:

    Specifies the waveform transformations for data read from, or
written to, the file pointed to by 'sp_file'.  The transformations are
specified in the string, 'mode'.  See the "Remarks" section for the
format and permissible values of this string.

Remarks:

    The 'mode' string argument specifies sample encoding and byte
order transformations to be performed by the SPHERE File I/O
functions, 'sp_read_data()' and 'sp_write_data()'.  (Future versions
may support sample rate transformations as well.)  The 'mode' string
has the following format:


        MODE        :==  <MODE_FLAG>:<MODE>
        MODE_FLAG   :==  SE-<SE_OPTIONS> | SBF-<SBF_OPTIONS>
        SE_OPTIONS  :==  PCM | PCM-1 | PCM-2 | ULAW | RAW | ORIG |
                         SHORTEN | WAVPACK
	SBF_OPTIONS :==  01 | 10 | 1 | N | ORIG

Mode Flag and Option Descriptions:

    SE -> specifies a transformation to the encoding of the sampled
	  waveform data.

        SE_OPTIONS:

            "PCM-2"   -> Read or write data as 2-byte PCM samples.
            "PCM-1"   -> Read or write data as 1-byte PCM samples.
            "PCM"     -> Synonym for "PCM-2"
            "ULAW"    -> Read or write data as 1-byte ULAW samples.
  	    "RAW"     -> Read or write data as 1-byte character
	                 stream (for unsupported data types).
            "ORIG"    -> Read or write data as-is.
	    "SHORTEN" -> Write data as Shorten-compressed byte stream.
	    "WAVPACK" -> Write data as Wavpack-compressed byte stream.
    
    SBF -> specifies a transformation to the byte format (byte order)
	   of the sampled waveform data.  This is only appropriate for
           multi-byte sampled data.

        SBF_OPTIONS:
            "01"      -> Read or write data as LSB/MSB.
            "10"      -> Read or write data as MSB/LSB.
            "1"       -> Read or write data as 1-byte samples.
            "N"       -> Read or write data as natural to the host.
            "ORIG"    -> Read or write data as-is.

Currently Supported Sample Encoding (SE) Read Transformations: ***

    PCM-2   -->  ULAW | RAW | ORIG
    PCM-1   -->  PCM-2 | ULAW | RAW | ORIG
    ULAW    -->  PCM-2 | PCM-1 | RAW | ORIG
    RAW     -->  ORIG
    SHORTEN -->  PCM-2 | PCM-1 | ULAW | RAW | ORIG
    WAVPACK -->  PCM-2 | PCM-1 | ULAW | RAW | ORIG
    
Currently Supported Sample Encoding (SE) Write Transformations: ***

    PCM-2   -->  PCM-1 | ULAW | ORIG | SHORTEN | WAVPACK 
    PCM-1   -->  PCM-2 | ULAW | ORIG | SHORTEN | WAVPACK 
    ULAW    -->  PCM-2 | PCM-1 | ORIG | SHORTEN | WAVPACK 
    RAW     -->  ORIG

*** NOTE: The current version of SPHERE does not support conversions
          to and from the ulaw sample format. 

Return Value:

    The value returned by 'sp_set_data_mode()' is 0 if the
transformation specified by 'mode' is supported, a 100 if
the transformation is not supported, and greater than
100 on error.

See Also:

    sp_read_data(), sp_write_data(), sp_open(), sp_close()


II.D   Status Functions

II.D.1 sp_eof()

Description:

    Returns the End-of-File (EOF) status of an opened SPHERE file.

Syntax:

    int sp_eof(SP_FILE *sp_file)
	
Arguments:

    sp_eof takes as it's argument a SPHERE file pointer, 'sp_file',
and returns the EOF status of that file.

Return Value:

    sp_eof returns a non-zero value if the end-of-file has been
reached during the last file read.  Otherwise, it returns a zero.

See Also:
    sp_read_data(), sp_error()


II.D.2 sp_error()

Description:

    Returns the error status of an opened SPHERE file.

Syntax:

    int sp_error(SP_FILE *sp_file)
	
Arguments:

    sp_error takes as it's argument a SPHERE file pointer, 'sp_file',
and returns the error status of that file.

Return Value:

    sp_error returns a zero if no errors occurred during the last file
I/O operation, a 100 if a checksum verification error occurred, or greater
than 100 if a fatal file I/O error occurred.

See Also:
    sp_read_data(), sp_write_data(), sp_eof()


II.D.3 sp_print_return_status()

Description:

    Prints the return status of the last SPHERE function call.

Syntax:

    int sp_print_return_status(FILE *fp)

Arguments:
    
    sp_return_status takes as it's argument an opened file pointer,
'fp', and prints a message indicating the sucess or failure of the
last SPHERE function called to 'fp'.

Remarks:

    sp_return_status prints the following report for the last
function called:

    Function: <function-name>
    Status code: <integer-value>
    Status type: <Success|Warning|Error>
    Message: <message-string>

Failures of child functions are recorded in the Message string.

Note: This is currently only defined for the SPHERE 2.0 C-language
Programmer Interface Library functions.

Return Value:
    
    sp_return_status a zero on sucess and a 100 or greater on error.


II.D.4 sp_return_status()

Description:

    Returns the return status of the last SPHERE function call.

Syntax:

    int sp_return_status()

Return Value:
    
    sp_return_status returns the status of the last SPHERE function
call.  The SPHERE 2.0 C-Language Programmers Interface Library functions
follow the conventions below for indicating Success, Warnings, or
Errors:

     	Return Condition	Possible Range of Values
	---------------- 	------------------------
	   Success		           0
	   Warning                        1-99
	   Fatal Error	             100 or greater

Note: This is currently only defined for the SPHERE 2.0 C-language
Programmer Interface Library functions.



III.  File Format Definition

SPHERE files contain a strictly defined header portion followed by
the file body (waveform).  Any waveform encoding may be used, but the
encoding must be sufficiently described in the header.

The header is an object-oriented, 1024-byte blocked, ASCII structure
which is prepended to the waveform data.  The header is composed of a
fixed-format portion followed by an object-oriented variable portion.
The fixed portion is as follows:

NIST_1A<new-line>
   1024<new-line>

The first line specifies the header type and the second line specifies the
header length.  Each of these lines are 8 bytes long (including new-line) and
are structured to identify the header as well as allow those who do not wish
to read the subsequent header information to programmatically skip over it. 

The remaining object-oriented variable portion is composed of
object-type-value "triple" lines which have the following format:


<LINE> --> <TRIPLE><new-line> |
           <COMMENT><new-line> | 
           <TRIPLE><COMMENT><new-line> | 

  <TRIPLE> --> <OBJECT><space><TYPE><space><VALUE><OPT-SPACES>

    <OBJECT> --> <PRIMARY-SUBOBJECT> | 
                 <PRIMARY-SUBOBJECT><SECONDARY-SUBOBJECT>

    <PRIMARY-SUBOBJECT> --> <ALPHA> | <ALPHA><ALPHA-NUM-STRING>
    <SECONDARY-SUBOBJECT> --> _<ALPHA-NUM-STRING> | 
                              _<ALPHA-NUM-STRING><SECONDARY-SUBOBJECT>

    <TYPE> --> -<INTEGER-FLAG> | -<REAL-FLAG> | -<STRING-FLAG>

      <INTEGER-FLAG> --> i
      <REAL-FLAG> --> r
      <STRING-FLAG> --> s<DIGIT-STRING>
      
    <VALUE> --> <INTEGER> | <REAL> | <STRING>  (depending on object type)

      <INTEGER> --> <SIGN><DIGIT-STRING>
      <REAL> --> <SIGN><DIGIT-STRING>.<DIGIT-STRING> 

    <OPT-SPACES> --> <SPACES> | NULL

  <COMMENT> --> ;<STRING>  (excluding embedded new-lines)

<ALPHA-NUM-STRING> --> <ALPHA-NUM> | <ALPHA-NUM><ALPHA-NUM-STRING>
<ALPHA-NUM> --> <DIGIT> | <ALPHA>
<ALPHA> --> a | ... | z | A | ... | Z
<DIGIT-STRING> --> <DIGIT> | <DIGIT><DIGIT-STRING>
<DIGIT> --> 0 | ... | 9
<SIGN> --> + | - | NULL
<SPACES> --> <space> | <SPACES><space>
<STRING> -->  <CHARACTER> | <CHARACTER><STRING>
<CHARACTER> --> char(0) | char(1) | ... | char(255)

The following fields are required for proper SPHERE I/O handling.
These fields completly describe the geometry of the data contained in
the SPHERE file.

        Field_name         Field_type
	----------         ----------
	sample_count           -i
	sample_n_bytes         -i
	channel_count          -i

The following fields are optional:

        Field_name         Field_type
	----------         ----------
	sample_checksum        -i       
        sample_coding          -s       (If missing, defaults to 'pcm')
        sample_byte_format     -s       (If missing, defaults to the Host's
                                         natural byte format.)

The following fields are conditionally required:

        Field_name         Field_type   Required if:
	----------         ----------   ------------
	sample_rate            -i       (the 'sample_coding' field is
					 missing, or contains 'pcm' or 'ulaw')

Possible values for these fields are:

	sample_count -> 1 .. MAXINT
	sample_n_bytes -> 1 | 2
	channel_count -> 1 .. 32
	sample_byte_format -> 01 | 10 | 1 (* See below for exception)
	sample_checksum -> 0 .. 32767
	sample_rate -> 1 .. MAXINT
	sample_coding -> pcm | ulaw | pcm,embedded-shorten-vX.X | 
			 ulaw,embedded-shorten-vX.X |
			 pcm,embedded-wavpack-X.X | 
			 ulaw,embedded-wavpack-X.X |
			 pcm,embedded-shortpack-X.X (Read Only)

	* Note: The original recordable CD-ROM release of WSJ0 incorporated
	        "shortpack" waveform compression.  The compression was 
		indicated by the now outmoded presence of the string,
		'shortpack-v0',	in the 'sample_byte_format' field.
		Since this software attempts to support all previous
		NIST releases of speech corpora, this "non-standard"
		field value is permitted.  Please note that this
		software will not generate files with this field value
		and that the LDC is producing a CD-ROM release of WSJ0
		which conforms to the specifications defined in SPHERE 2.0.

The single object "end_head" marks the end of the active header and the
remaining unused header space is undefined. A sample header is included
below.

Example SPHERE header from the TIMIT corpus (NIST Speech Disc 1-1.1):

NIST_1A
   1024
database_id -s5 TIMIT
database_version -s3 1.0
utterance_id -s8 aks0_sa1
channel_count -i 1
sample_count -i 63488
sample_rate -i 16000
sample_min -i -6967
sample_max -i 7710
sample_n_bytes -i 2
sample_byte_format -s2 01
sample_sig_bits -i 16
end_head


Example SPHERE header from the CSR Phase II corpus:

NIST_1A
   1024
microphone -s21     Sennheiser HMD414
recording_site -s4  SRI
database_id -s8     wsj1
database_version -s3 1.0
recording_environment -s38 quiet office, door closed (room EJ186)
speaker_session_number -s2 01
session_utterance_number -s2 01
prompt_id -s8 adapt.01
utterance_id -s8 460a0101
speaking_mode -s15 read-adaptation
speaker_id -s3 460
sample_count -i 82561
sample_min -i -560
sample_max -i 655
sample_checksum -i 27320
recording_date -s11 11-Nov-1992
recording_time -s11 12:14:16.00
channel_count -i 1
sample_rate -i 16000
sample_n_bytes -i 2
sample_byte_format -s2 01
sample_sig_bits -i 16
sample_coding -s25 pcm,embedded-shorten-v1.1
end_head



IV.  File Pointer Structure

The following is a description of the file pointer structure used by
SPHERE to address opened files.

The structure includes pointers to the parsed header, the waveform,
and a structure used by SPHERE to track the status of various
operations on the opened file.

NOTE:   The SPHERE file pointer structure has been designed to be used
	exclusively by the SPHERE library functions.  The programmer
	should only include the structure in argument lists passed to
	SPHERE function calls.  The programmer should NOT attempt to
	manipulate this structure directly.


    SPHERE Structure 'SP_FILE' 

	typedef struct sphere_t SP_FILE;

	struct sphere_t {
       		struct header_t *header;
                struct waveform_t *waveform;
		struct spfile_status_t *status;
	};

        struct waveform_t {
	        /* This structure is intended for use only by */
		/* the SPHERE-library functions               */
        };

        struct spfile_status_t {
	        /* This structure is intended for use only by */
		/* the SPHERE-library functions               */
	};

	struct header_t {
	        /* This structure is intended for use only by */
		/* the SPHERE-library functions               */
	};



V.  Installation

To install SPHERE on a Unix system, cd into the 'nist' directory of
the SPHERE distribution hierarchy and type the command:

	sh src/scripts/install

The SPHERE libraries will be created and placed in the 'lib'
directory, and the sample programs, described in the 'System-Level
Utilities' section, will be compiled and placed in the 'bin'
directory.  Installation on non-Unix systems without "make" and "sh"
will probably require manual compilation.  The next release of SPHERE
will support compilation of SPHERE on PC's.

Included with this release is a functional interface test program
which exercises various header manipulation and waveform
compression/decompression functions.  To run the test, execute the
command from the 'nist' directory in the distribution hierarchy:

	tsphere -d lib/data

The program requires the files in the 'lib/data' directory of the
SPHERE distribution hierarchy.  If all is well, the program will run
without errors.  If an error occurs, send a bug report as specified in
the 'Bug Reports' section.



VI.  Linking to the SPHERE library

User programs are linked with two object code libraries:

	libsp.a       - user level SPHERE functions
			include compression code
	libutil.a     - SPHERE-internal functions

Both libraries must be 'linked' for successful use of SPHERE.
During the installation process, the source code for these
libraries is placed in the 'lib' directory of the distribution
hierarchy.   

User programs must include the following line in order to link
with the SPHERE libraries:

	#include <sp/sphere.h>

This include file references all of the required library files.

To compile a program, such as the command-line SPHERE utility,
'w_decode', which is found in the 'src/prog' directory, execute
the following command:

	cc -L<INSTALL_DIR>/nist/lib -I<INSTALL_DIR>/nist/include \
		-o w_decode w_decode.c -lsp -lutil -lm

        where "INSTALL_DIR" is the directory where the SPHERE library
        source code is located.

If an unresolvable error occurs in compiling a program which uses the
SPHERE library, you may send a bug report as specified in the 'Bug
Reports' section and someone will assist you.



VII.  Example Interface Library Usage

Example 1: To load the embedded shorten-compressed 2-byte-per-sample
PCM file, "file.wav", into memory in its uncompressed form.

    SP_FILE *sp;
    short *waveform;
    long channel_count, sample_n_bytes, sample_count;
    int wave_byte_size, total_samples;

    if ((sp = sp_open("file.wav","r")) != (SP_FILE *)0) {
        fprintf(stderr,"Error: Unable to open SPHERE file %s\n","file.wav");
        return(-1);
    }

    if (sp_h_get_field(sp,"channel_count",T_INTEGER,&channel_count) > 0)
	return(-1);
    if (sp_h_get_field(sp,"sample_n_bytes",T_INTEGER,&sample_n_bytes) > 0)
	return(-1);
    if (sp_h_get_field(sp,"sample_count",T_INTEGER,&sample_count) > 0)
	return(-1);

    total_samples=sample_count * channel_count;
    wave_byte_size=sample_n_bytes * total_samples;

    if ((waveform=(short *)malloc(wave_byte_size)) == (short *)0){
        fprintf(stderr,"Error: Unable to allocate %d bytes for the waveform\n",
                       wave_byte_size);
        exit(-1);
    }
    
    if (sp_read_data(waveform,sample_n_bytes,total_samples,sp) !=
                     total_samples){
        fprintf(stderr,"Error: reading speech waveform\n");
	sp_return_status(stderr);
        exit(-1);
    }
                     .
                     .
                     .

    sp_close(sp);  /* deallocates the header & buffers */


Example 2: To load a single-channel ulaw file, "ulaw.wav", and convert
it to a 2-byte-per-sample PCM format.

    SP_FILE *sp;
    short *waveform;
    long channel_count, sample_n_bytes, sample_count;
    int wave_byte_size, total_samples;

    if ((sp = sp_open("ulaw.wav","r")) != (SP_FILE *)0) {
        fprintf(stderr,"Error: Unable to open SPHERE file %s\n","file.wav");
        return(-1);
    }

    sp_data_mode(sp, "SE-PCM-2");

    if (sp_h_get_field(sp,"channel_count",T_INTEGER,&channel_count) > 0)
	return(-1);
    if (sp_h_get_field(sp,"sample_n_bytes",T_INTEGER,&sample_n_bytes) > 0)
	return(-1);
    if (sp_h_get_field(sp,"sample_count",T_INTEGER,&sample_count) > 0)
	return(-1);

    total_samples=sample_count * channel_count;
    wave_byte_size=sample_n_bytes * total_samples;

    if ((waveform=(short *)malloc(wave_byte_size)) == (short *)0){
        fprintf(stderr,"Error: Unable to allocate %d bytes for the waveform\n",
                       wave_byte_size);
        exit(-1);
    }
    
    if (sp_read_data(waveform,sp->sample_n_bytes,total_sample,sp) !=
                     total_samples){
        fprintf(stderr,"Error: reading speech waveform\n");
	sp_return_status(stderr);
        exit(-1);
    }
                     .
                     .
                     .

    sp_close(fp);  /* deallocates the header & buffers */


Example 3: To load the SPHERE file, "file.wav", update the contents
of the header, and then change the header on disk.

    SP_FILE *sp;
    char *db_version, new_db_version[10];

    if ((sp = sp_open("file.wav","u")) != (SP_FILE *)0) {
        fprintf(stderr,"Error: Unable to open SPHERE file %s\n","file.wav");
        return(-1);
    }

    /******  Delete a header field  ******/
    if (sp_h_delete_field(sp,"prompt_id") == 0){
        fprintf(stderr,"Error: Unable to delete header field");
	fprintf(stderr," 'prompt_id' from %s\n", "file.wav");
        fprintf(stderr,"       Field does not exist\n");
        break;
    } else {
        fprintf(stderr,"Error: Unable to delete header field");
	fprintf(stderr," 'prompt_id' from %s\n", "file.wav");
	sp_return_status(stderr);
        return(-1);
    }

    /******  Add a header field  ******/
    if (sp_h_set_real(sp, "signal-to-noise", 55.4) > 0){
	fprintf(stderr,"Error: Unable to add the 'signal-to-noise' field ");
        fprintf(stderr," %s\n","file.wav");
	sp_return_status(stderr);
        return(-1);
    }

    /******  Change a header field  ******/
    if (sp_h_get_string(sp, "database_version", &db_version) > 0){
	fprintf(stderr,"Error: Unable to get the 'database_version' field from %s\n",
	               "file.wav");
	sp_return_status(stderr);
        return(-1);
    }
    sprintf(new_db_version,"%3.2f",atof(db_version)+1.0);
    if (sp_h_set_string(sp, "database_version", new_db_version) > 0){
	fprintf(stderr,"Error: Unable to set the 'database_version' field from %s\n",
	               "file.wav");
	sp_return_status(stderr);
        return(-1);
    }
    free(db_version);


             .
             .
             .

    sp_close(fp);  /* deallocates the header & buffers */



VIII.  System-Level Utilities

    The following are command-line utilities which have been created using
    the SPHERE libraries.  These programs provide the ability to read,
    write, and modify SPHERE headers and to compress/decompress
    SPHERE-headered waveforms.

    h_read [options] [file ...]
        reads headers from the files listed on the command line; by default,
	output is lines of tuples consisting of all fieldnames and values;
	many options modify the program's behavior; see the manual page
	"h_read.1";

    h_add inputfile outputfile
        adds an empty header to the "raw" unheadered speech samples in
	inputfile and stores the result in outputfile;

    h_strip inputfile outputfile
        strips the SPHERE header from inputfile, stores the remaining data in
	outputfile; if outputfile is "-", writes the sample data to "stdout";

    h_edit [-uf] [-D dir] -opchar fieldname=value ... file ...
    h_edit [-uf] [-o outfile] -opchar fieldname=value ... file
        edit specified header fields in the specified file(s).  In the first
	form, it either modifies the file(s) in place or copies them to the
	specified directory "dir".  In the second form, it either modifies
	the file in place or copies it to the specified file "outfile".

        The "-u" option causes the original files to be unlinked (deleted)
	after modification.  The "-f" option forces the program to continue
	after reporting any errors.

        The "opchar" must be either "S","I", or "R" to denote string,
	integer, or real field types respectively.

    h_delete [-uf] [-D dir] -F fieldname ... file ...
    h_delete [-uf] [-o outfile] -F fieldname ... file
        delete specified header fields in the specified file(s). In the first
	form, it either modifies the file(s) in place or copies them to the
	specified directory "dir".

        In the second form, it either modifies the file in place or copies it
	to the specified file "outfile".

        The "-u" option causes the original files to be unlinked (deleted)
	after modification.  The "-f" option forces the program to continue after
	reporting any errors.

    w_encode [-mvf] -t [ wavpack | shorten | ulaw ]  file_in file_out
    w_encode [-mvi] -t [ wavpack | shorten | ulaw ]  file1 file2 . . . 
        Encode the file as the type defined by the "-t" option.  The program
	will use the header information to optimize the compression scheme.
	The default operation is to encode the file specified in
	"file_in" and place the contents into the file specified in
	"file_out".  If the filenames specified in "file_in" or "file_out"
	are "-", then stdin and stdout are used respectively.  In addition,
	an error will be generated if "file_out" already exists. The "-f"
	option causes an existing "file_out" to be overwritten.

        The waveform I/O routines automatically convert the byte order of a
	file to the host machine's natural format.  The "-m" option forces
	the encoding to maintain the original byte order of "file_in".

        The "-i" option forces w_encode to replace the input file with it's
	encoded version.  When this "in place" option is used, the header is
	modified to indicate the new encoding as well.  This option also
	allows more than one input file to be specified on the command line.

        The "-v" option gives verbose output.

    w_decode [-vf] -o [ short_10 | short_01 | short_natural | ulaw ]  file_in file_out
    w_decode [-vi] -o [ short_10 | short_01 | short_natural | ulaw ]  file1 file2 . . . 
        Decode the input file into the output format specified by "-o".  If
	the file is already encoded as specified, no action is taken.

        w_decode reads the header and sample data and performs conversions on
	the output as necessary.  The default operation is to decode the file
	specified in "file_in" and place the contents into the file specified
	in "file_out".  If the filenames specified in "file_in" or "file_out"
	are "-", then stdin and stdout are used respectively.  In addition,
	an error will be generated if "file_out" already exists.  The "-f"
	option causes an existing "file_out" to be overwritten.

        The "-i" option forces w_encode to replace the input file with it's
	encoded version.  When this "in place" option is used, the header is
	modified to indicate the new encoding as well.  This option also
	allows more than one input file to be specified on the command line.

        The "-v" option gives verbose output.


IX.  Revision History

Changes in Release 1.5:

	1. New functions were added to the Sphere library:
		sp_get_fieldnames()
		sp_get_type()
		sp_get_size()
		sp_is_std()

		(see the sphere library man page for descriptions)

	2. h_read: command line options were changed

	3. h_strip: writes to stdout if destination is "-"

	4. man page for h_read


Changes in Release 1.6:

	1. Utilities that use h_modify.c are now much faster in
		most cases when editing in-place -- if the size
		of the header does not change, the new header is
		copied over the old one.

	2. Modified sp_write_header() to work when writing to
		objects other than files. The function ftell()
		was previously used directly on the output
		stream to ascertain the number of bytes
		in the header; now the header is written
		to a temp file to ascertain the header size,
		then to the output stream.

	3. Modified to sp_open_header() and spx_read_header()
		to no longer test if the input file is at
		position 0. This will allow reading from
		pipes, etc.

	4. h_add: can read from stdin and/or write to stdout;
		no longer puts any dummy fields in the header.

	5. h_strip: can now read from stdin in addition to
		writing to stdout.

	6. Added h_header and raw2nist to the Sphere package.
		They are Bourne shell scripts (/bin/sh) to,
		respectively, print file headers and convert raw
		data (no header) to Sphere format.

	7. Manual pages for commands h_edit, h_delete, h_add,
		h_strip and raw2nist

Changes in Release 1.7:

	1. h_read: added "-C field" option to check that the
		specified field(s) is in the headers of all files
		on the command line.

Changes in Release 2.0 Beta:

	1. SPHERE now has a new functional interface to waveform data
		and headers.  The unified approach is detailed in the
                "C-Language Programmer Interface Library" section.

	2. Library libsp.a won't be removed if "make" is interrupted.

	3. Using ANSI functions instead of BSD equivalents:
		index() -> strchr()
		rindex() -> strrchr()
		bcopy() -> memcpy()
		bzero() -> memset()

	4. Include file changes:
		<stdlib.h>: rand(), malloc(), realloc(), etc.
		<string.h>: replaces <strings.h>
		<errno.h>: errno
		"getopt.h": getopt(), optind, optarg

	5. The function getopt() is now expected to return -1
		when there are no more command line arguments
		to be parsed. Previously, it was expected  to
		return EOF.  resetopt() clears the history state
		of getopt() to enable re-using getopt().

	6. New programs "w_encode" and "w_decode" allow sampled
                waveform data to be compressed (w_encode) or
                decompressed (w_decode) using either the "wavpack" or
                "shorten" algorithms.

	7. Waveform encoding functions added including a set
                to allow data to be compressed using the "wavpack" or
		"shorten" algorithms with input and/or output
		data coming from memory or a file pointer, and
		a set of analogous functions for decompression.
	
Changes in Release 2.0 Beta 2:

	1. Corrected Known Software Bugs:
		a. The function 'set_data_mode' should have been named 
		   'sp_set_data_mode'.
		b. Waveforms without checksums are now readable.
		c. the installation process was updated.

	2. Function Changes:
		a. The function 'sp_return_status' was renamed to 
		   'sp_print_return_status'.
		b. A new function was written 'sp_get_return_status'
		   which allows the programmer to retrieve the return
		   status of the last function call.		   

	3. Merged the libraries to simplify the linking procedures.
		- see the Linking to the SPHERE library Section of the
		  SPHERE Manual

	4. Re-designation of required header fields.
		- see the File Format Definition Section of the
		  SPHERE Manual

	5. Decompression will use a temporary file if the waveform size
	   is larger the a specified byte size.  (Details of modifying the
	   variable will be added to the installation script in a future
	   release.)

	6. Addition of 'shortpack' decompression to facilitate reading
	   of the WSJ0 Write-Once CD-ROMS.


Changes in Release 2.0 Beta 2.1:
	
	1. Corrected an unclosed file pointer problem which was activated
	   when uncompressing files.

X.  Bug Reports

Please send bug reports to 'sphere-bugs@jaguar.ncsl.nist.gov'.  Or via
postal-mail to:

	Jon Fiscus
	National Institute of Standards and Technology
	Bldg. 225, Room A-216
	Gaithersburg, MD 20899



XI.  Supported Hardware

The SPHERE functions and programs have been developed in Sun-C on a
Sun Microsystems workstation running SunOS 4.1.1 and 4.1.2.  To date,
SPHERE 2.0 has been tested on SPARC-based UNIX systems, NeXT 
workstations, and DEC Alpha Workstations.  It is currently being
tested on a SGI Indigo workstation.

Once SPHERE 2.0 has completed Beta testing, NIST plans to converting
it to ANSI C for maximum portability.  NIST then plans to port SPHERE
to the PC platform.



XII.  Disclaimer

These software tools have been developed for use within the ARPA
speech research community.  Although care has been taken to ensure
that this software is complete and error-free, it may not meet all
users' requirements.  As such, it is made available to the speech
research community at large, without endorsement, or express or
implied warranties by the National Institute of Standards and
Technology, the Department of Defense, or the United States
Government.



XIII.  Acknowledgements

The SPHERE file format was designed by John Garofolo at NIST.

The SPHERE-internal low-level functions were designed by John Garofolo
and Stanley Janet and coded by Stanley Janet at NIST.

The SPHERE 2.0 Programmer Interface Library was designed by John
Garofolo and Jon Fiscus and coded by Jon Fiscus at NIST.

The Shorten compression algorithm was developed and implemented by
Tony Robinson at Cambridge University.

The Wavpack compression algorithm was developed and implemented by
Doug Paul at MIT Lincoln Laboratories.

NIST would like to thank those people who provided constructive
suggestions during the design of SPHERE 2.0. and NIST would like to
particularly thank Tony Robinson for his help in integrating 'shorten'
into the SPHERE interface.
